# 单币种多网格交易系统（极简需求文档）
https://developers.binance.com/docs/zh-CN/derivatives/Introduction  binance官方API地址
服务退出或重启前，显式关闭 HTTP/WS 客户端（如 await exchange.close()/自研 client Close()），消除 ‘Unclosed client session/connector’
## 1. 核心概念

### 1.1 网格段落定义

- **X 段**：X1–X2 为网格区间，步长 X3（U/格），每格下单 X4（币）。最大买挂 X7、最大卖挂 X7。
- **A 段**：A1–A2 区间，步长 A3，每格 A4。最大买挂 A7、最大卖挂 A7。
- **B 段**：B1–B2 区间，步长 B3，每格 B4。最大买挂 B7、最大卖挂 B7。

### 1.2 订单类型定义

- **买入建仓**（多网格的下侧格）：BUY, positionSide=LONG, LIMIT GTC
- **止盈卖出**（对应该格的卖单）：SELL, positionSide=LONG, reduceOnly=true, LIMIT GTC

> ⚠️ 注意：卖单用来"平掉该格多仓"，必须明确设置 positionSide=LONG + reduceOnly=true，否则在双向持仓下容易误开空仓。

### 1.3 总挂单上限

- 计算公式：X7*2 + A7*2 + B7*2 < 200
候补（本地）计划买单不得触发卖侧；仅当该格出现 BUY_FILLED（真实成交）才允许挂对价卖单，且卖单 reduceOnly=true
反之同理，卖单真实成交才允许改网格重新挂买单
- 超出目标：放本地内存队列，异步写入JSON文件（可扩展为数据库）

## 2. 交易逻辑

### 2.1 配对规则

- 买入后卖出，算一次配对

- 未成交等待挂单单独存储，与已配对文件和日志文件分开（用于断电恢复/对齐）

### 2.2 简单示例

以X段为例：
- 价格区间：4450-4476
- 步长：2（U/格）
- 每格下单量：0.01 ETH
- 最大挂买单数：10
- 最大挂卖单数：10

**操作逻辑**：
- 4476为最大一格，不做买入
- 实际最大买单应为4474，且买单挂单价要小于市价
- 当前市价4474，挂单价格：4472, 4470, 4468, 4466, 4464, 4462, 4460, 4458, 4456, 4454
- 市价上涨到4475时，为维持最大10个买单，需撤掉4454的买单，新增4474的买单
网格引擎产出“目标挂单集合” ↔ 交易所 openOrders 做集合差分：只“补缺/撤多，
Binance 期货不支持直接改价；任何“改价”一律 cancel → new order，同格仅一张活跃单。
### 2.3 订单号规则

- 使用UUIDv4生成本地自定义订单号，保证幂等性
- 自定义订单ID（clientOrderId）≤36字符
- 同一网格仅允许1张活跃买单，该格处于"买入未卖出"期间不再追加买单
- 不允许漏网格：买了必挂卖；卖了（条件满足）必回补买

## 3. 系统架构

### 3.1 启动流程

1. 连接WebSocket API行情接口
2. 连接WebSocket API用户数据流
3. 开始订单操作

### 3.2 API接口

#### REST API
- 账户成交历史 (USER_DATA)

#### WebSocket
- 账户余额（USER_DATA）—— 主动推送
  - 机制：当账户余额发生任何变化时，Binance会自动推送 account 事件
- 订单事件（USER_DATA）—— 主动推送
  - 机制：当订单状态变化时，Binance会自动推送 order 事件


### 3.3 WebSocket连接优化

- 初始化WebSocket：使用listenKey认证，60 分钟有效，≤30 分钟 keepalive 一次；收到 listenKeyExpired 或 401/掉线后立即重建+一次性"轻对账"
- 断联重连：直接复用旧Key，原Key过期时生成新的listenKey
单连 24h 强制断开需要自动重连 + 重订阅，进入“RECOVERING”，跑一次 REST 对齐后回 NORMAL
- 启动心跳：15-25秒发送一次ping消息
- 设置重连：指数退避（1s→2s→4s→8s→16s→30s）
- 添加错误日志：记录所有连接状态变化

传输心跳（ping/pong）由底层维持即可；应用层只保留业务心跳（最近事件时间），≥25s 无帧才触发降级。

## 4. 异常处理机制

### 4.1 防重复挂单机制
下单流程（带写屏障）
1. 本地用UUIDv4生成clientOrderId订单号，然后尝试挂单

生成 clientOrderId，在内存登记（state=INTENT）并写 ledger.jsonl 一条 ORDER_INTENT；

调 REST POST /fapi/v1/order 下单；

成功 → 记 ORDER_PLACED（同步 flush+fsync）；失败且超时 → 调 GET /fapi/v1/order?origClientOrderId=... 核对是否已被交易所接受；

无论 WS/REST 哪个先回，都以同一 Reducer推进（幂等：状态只前进，filled=max()）；

如需改价：先撤旧（CANCELED）→ 再 ORDER_PLACED 新价；同格最多一张活跃单

2. WS断联期间有成交订单处理
   - WS重连成功后，通过REST查询所有订单（包括历史订单）
   - 用返回的订单数据更新本地记录，执行对应动作
   - 禁止"因为REST查询没回就再下单"

### 4.2 降级模式

#### 两种心跳区分
- **传输心跳**（Transport heartbeat）：WS的ping/pong或底层帧时间戳
- **业务心跳**（Business heartbeat）：上次收到订单/成交事件的时间戳

#### 进入降级的唯一触发条件
- now - last_ws_frame_ts > 25s（传输层真的超过25秒没任何帧）
- 判定为WS异常/掉线，进入DEGRADED状态

#### DEGRADED模式操作（每2秒一轮）
1. GET /fapi/v1/userTrades 用 since_cursor 拉最近成交
2. GET /fapi/v1/openOrders 拉当前未成交订单
3. GET /fapi/v2/positionRisk 拉当前持仓
   userTrades/allOrders 一律带游标（startTime/orderId）分页拉；把 REST 结果转事件进入同一 Reducer（幂等更新）。
   
   原因：避免一次全量查询打满权重；保证恢复一致性。
4. 将结果统一翻译成统一事件并走同一个 Reducer（与 WS 完全同路），WS 恢复后先对齐一次再退出
5. 若WS恢复（收到帧），再跑一次对齐后退出降级

## 5. 数据结构设计

### 5.1 订单状态流转（5阶段）

| 状态 | Binance原始值 | 说明 | 是否终结状态 | 本地处理逻辑 |
|------|----------------|------|--------------|--------------|
| 1. 挂单中 | NEW | 订单已提交但未成交 | ❌ 否 | 本地状态 = NEW，等待WS更新 |
| 2. 部分成交 | PARTIALLY_FILLED | 已成交部分数量 | ❌ 否 | 1. 更新 executedQty<br>2. 记录 executions 表 |
| 3. 完全成交 | FILLED | 已成交全部数量 | ✅ 是 | 1. 标记为 FILLED<br>2. 触发配对逻辑 |
| 4. 已撤单 | CANCELED | 用户主动取消 | ✅ 是 | 1. 标记为 CANCELED<br>2. 取消配对 |
| 5. 已过期 | EXPIRED | 订单超时未成交 | ✅ 是 | 1. 标记为 EXPIRED<br>2. 取消配对 |

### 5.2 订单主表（orders）

记录订单基础信息（所有订单必存）

| 字段 | 类型 | 说明 | 必填 | 示例 |
|------|------|------|------|------|
| clientOrderId | string | 唯一ID（UUID格式） | ✅ | "a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d" |
| orderId | string | Binance返回的订单ID | ✅ | "1234567890" |
| symbol | string | 交易对 | ✅ | "BTCUSDT" |
| status | string | 当前状态（Binance原始状态） | ✅ | "FILLED" |
| orderType | string | 订单类型 | ✅ | "LIMIT" |
| side | string | 买卖方向 | ✅ | "BUY" |
| price | float | 限价 | ✅ | 60000.0 |
| origQty | float | 原始数量 | ✅ | 0.001 |
| executedQty | float | 已成交数量 | ✅ | 0.0005 |
| createdAt | timestamp | 下单时间（UTC） | ✅ | 2025-04-01T12:00:00Z |
| updatedAt | timestamp | 最后更新时间 | ✅ | 2025-04-01T12:00:30Z |

### 5.3 成交明细表（executions）

记录每次成交的细节（仅部分成交订单需存）

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| orderId | string | 关联主表的orderId | "1234567890" |
| tradeId | string | Binance的成交ID | "123456789" |
| price | float | 成交价格 | 60000.0 |
| qty | float | 成交数量 | 0.0005 |
| time | timestamp | 成交时间 | 2025-04-01T12:00:30Z |

### 5.4 操作日志表（operations）

记录所有系统操作（防重复下单核心）

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| clientOrderId | string | 唯一订单ID | "a1b2c3d4-e5f6-..." |
| operation | string | 操作类型 | "PLACE_ORDER" |
| status | string | 操作结果 | "SUCCESS" |
| timestamp | timestamp | 操作时间 | 2025-04-01T12:00:00Z |
| retryCount | int | 重试次数 | 0 |
| response | json | API返回原始数据 | {"orderId":"123456",...} |

### 5.5 订单配对表（order_pairs）
gridLegId 是本地自定义的配对键（通常用“买单 clientOrderId”派生），用于把“该格的买腿”和“对应卖腿”强绑定。

tradeId 是 Binance 的成交粒度 ID，一个订单可有多个 tradeId。

推荐：卖单 clientOrderId 前缀带 gridLegId，配对靠 gridLegId + orderId/clientOrderId
| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| tradeId | string | Binance唯一成交ID | "123456789" |
| buyOrderId | string | 买单的orderId | "1234567890" |
| sellOrderId | string | 卖单的orderId | "0987654321" |
| price | float | 成交价格 | 60000.0 |
| qty | float | 成交数量 | 0.001 |
| matchedAt | timestamp | 配对时间 | 2025-04-01T12:00:30Z |

### 5.6 配对逻辑设计

✅ 网格腿ID gridLegId（= 买单的 clientOrderId 派生）做唯一配对键；卖单 clientOrderId 带上 gridLegId 前缀；关联依赖 orderId/clientOrderId

| 字段 | 说明 | 为什么必须用它 |
|------|------|----------------|
| gridLegId | 自定义生成 | Binance唯一标识一笔成交，100%关联买卖双方 |
| orderId | Binance的订单ID | 不能用于配对（同一笔成交可能有多个订单） |
| clientOrderId | 本地生成的UUID | 不能用于配对（仅用于防重复下单） |

## 6. 交易执行逻辑

### 6.1 撮合与下单

- 全程使用限价单，允许滑点
- 只在市价下方挂买单
- 买单成交后，按"买价 + 对应步长"挂卖单
- 区间的最后一格不做买入（顶格不买）

### 6.2 部分成交处理
下单前检查与对齐

从 exchangeInfo 载入 PRICE_FILTER.tickSize、LOT_SIZE.stepSize/minQty、（若有）NOTIONAL/minNotional；

价格对齐：买单向下对齐到 tickSize 整数倍；卖单向上对齐到 tickSize 整数倍；

数量对齐：数量向下对齐到 stepSize 整数倍；

阈值校验：alignedQty ≥ minQty 且 alignedQty × alignedPrice ≥ minNotional，不通过则拒下并记 rejections.jsonl；

部分成交判定：完成买侧阈值 = max(minQty, minNotional / 计划买价)，达到即触发卖侧（撤掉买单余量后按计划卖价挂出）。

## 7. 系统限制与错误处理

### 7.1 交易所限额

- 双向持仓模式
- WS监听订单成交与行情价格
- REST下单

#### 请求权重限制
- 1分钟内的请求权重上限为2400

#### 订单数量限制
- 1分钟内最多可提交1200个订单
- 10秒内最多可提交300个订单

### 7.2 错误处理机制

- 收到429时，进行退避，而不是向API发送垃圾邮件
- 重复违反速率限制将导致自动IP封禁（HTTP状态418）
- IP封禁持续时间：2分钟到3天不等
- 收到429或418时，停止发送请求

### 7.3 其他限制

- 余额不足：停止挂买，等待卖出后继续；每3分钟检查余额，有增加即恢复
- 价格超出网格区间：暂停，回到区间自动恢复

## 8. 人工调整功能

- 上移区间：按新参数执行；不在新区间内的旧挂单撤掉
- 下移区间：已有仓位按原规则在到价时卖出；新低位按新参数建单（仍遵守最大买/卖挂数量）
- 修改每格下单数量：新买按新数量执行；已有仓位按原数量卖出

## 9. UI需求

### 9.1 统计信息

- 输出两项即可：总匹配次数、各网格匹配次数
- 设置参数后面加个修改参数

### 9.2 参数设置

- 价格区间、步长（网格间隔）、每格下单数量、方向（做多）、杠杆
- 存储：内存+JSON，启动后用交易所的未成交订单与当前持仓恢复现场

## 10. 日志与文件管理

### 10.1 目录结构

```
/data/
  ledger.jsonl           # 事件流水：一行一条JSON（下单ACK/成交/撤单/状态推进/人工干预）
  snapshot.json          # 周期快照：内存权威状态的全量镜像
  deferred_queue.jsonl   # 候补挂单池：超出最大活跃挂单时排队
  rejections.jsonl       # 被拒单记录：错误码、原因
  logs/app.log           # 运行日志（结构化行）
```

### 10.2 事件记录（ledger.jsonl）

追加写，关键事件立即 flush+fsync

**事件类型**：
- 下单成功ACK：ORDER_PLACED
- 成交：ORDER_FILLED（含filled/avgPx）
- 撤单：ORDER_CANCELED
- 人工动作：MANUAL_*（见下）
- 状态推进/配对成功：GRID_PAIRED、BUY_TO_SELL、SELL_TO_BUY等

**示例**：
```json
{"ts":1737523456123,"seq":101,"type":"ORDER_PLACED","oid":"g_X_4477000_b1","grid":"X_4477000","side":"BUY","px":4477.0,"qty":0.01}
{"ts":1737523456999,"seq":102,"type":"ORDER_FILLED","oid":"g_X_4477000_b1","filled":0.01,"avg_px":4477.0}
{"ts":1737523457123,"seq":103,"type":"ORDER_PLACED","oid":"g_X_4477000_s1","grid":"X_4477000","side":"SELL","px":4480.0,"qty":0.01,"reduceOnly":true}
```

在 ledger.jsonl 加 source（WS/REST）、latency_ms 字段；方便排查"漏单在 WS 还是在 REST"。

### 10.3 快照机制（snapshot.json）

原子写（.tmp → rename）

**内容**：
- order_index（按oid的状态）
- grid_index（每格是否有活跃买/卖）
- cursors（对账游标）

**触发条件**：
- 每60秒或累计100条事件落一次

### 10.4 候补池（deferred_queue.jsonl）

当活跃挂单已达到上限，新计划单写入此文件，字段：grid/side/px/qty/reason

有额度时从队头拉起实盘下单，并在ledger.jsonl追加DEFERRED_APPLIED

### 10.5 拒单记录（rejections.jsonl）

所有被拒的请求：time, oid, side, px, qty, code, msg, raw_response，用于回溯

### 10.6 运行日志（logs/app.log）

结构化行，字段包含：level, ts, module, msg, symbol, grid, oid, side, px, qty, code, latency_ms

**日志轮转**：
- 按天或50MB滚动
- 保留最近7天
- 过期压缩或删除

### 10.7 写入策略

- 事件关键节点（ACK/FILLED/CANCELED/DEFERRED_*）→ 同步flush + fsync（确保掉电不丢）
- 其它事件/指标 → 200ms批量写
- 单进程写：若未来多进程，再升级为SQLite/Postgres（但接口不变）

## 11. 启动恢复流程

1. 读取snapshot.json到内存
2. 扫描ledger.jsonl大于snapshot.seq的行回放
3. 立即执行一次"轻对账"（见降级里的1/2/3步），把REST结果也变成事件喂Reducer → 完全对齐
4. 处理deferred_queue.jsonl：有额度就拉起挂单

启动恢复：加时间同步（serverTime 校时，处理 -1021），recvWindow 统一 5s；避免签名时间漂移导致间歇性失败。